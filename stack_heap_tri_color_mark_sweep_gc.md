# stack and heap and tri-color mark sweep garbage collection

每个 goroutine 维护一个 stack，预申请的内存段，作为内存池供某些内存块从中开辟。每个 goroutine 初始栈大小 2KiB。运行时按需要增长、收缩。

开辟在 goroutine 维护stack上的内存块只能被此 goroutine 内部使用，其它 goroutine 无法访问，同 goroutine 内可以不通过任何数据同步技术使用开辟在它stack上的内存块上的值部

heap 是一个虚拟概念，每个程序只有一个heap，一般地，如果一个内存块没有开辟在stack上，我们说它是开辟在heap上。开辟在堆上的内存块可以被多个 goroutine 并发访问，需要的时候要对值部做同步。

compiler 判断一个内存块在运行时会被多个 goroutine 访问，或不能断定此内存块是否只被一个 goroutine 访问，此内存块会被开辟在堆上。

逃逸：局部声明的变量的某些值被开辟在堆上，称这些值和此局部变量逃逸到了堆上

+ 某结构体的某字段逃逸到了堆上，则此整个结构体值也逃逸到堆上
+ 某数组的某元素逃逸到堆上，则此整个数组也逃逸到堆上
+ 某切片的某元素逃逸到堆上，切片中所有元素都将逃逸到堆上，但切片值的直接部分可能开辟在栈上
+ 某值部v被某逃逸到堆上的值引用，此值部v也将逃逸到堆上

## tri-color mark sweep garbage collection

[tri-color-hybrid-write-barrier-by-AceId](https://zhuanlan.zhihu.com/p/334999060)

+ 垃圾回收开始，所有内存块被标记为白色
+ 将所有开辟在stack和全局内存区上的内存块标记为灰色，并把它们加入一个灰色内存块列表
+ 循环下面两步直到灰色内存块清空
  + 从灰色内存块列表中取出一个内存块，并把它标记为黑色
  + 扫描此内存块上的指针值，通过这些指针找到它们引用着的内存块。如果一个引用着的内存块为白色，则将其标记为灰色并加入灰色内存块列表；否则忽略

write-barrier-golang: 某已经被标记为黑色的内存块在标记过程中被修改而使其新引用着的某仍标n记为白色的内存块时，此白色内存块需要被标记为灰色，否则此白色内存块可能被认为是垃圾而回收掉。

并行的三色标记，如果没有STW，两个问题：
+ 某白色对象被黑色对象引用（白色挂在黑色下）
+ 灰色对象与某白色对象的可达关系被破坏（灰色**同时**丢失白色）

> 为什么会产生问题？<br/>
> 黑色是已扫描，灰色是未扫描；e.g. 若某白色同时被黑色、灰色引用，并发操作解除白色和灰色的引用关系，则该白色不会被检查并被直接清除

引出强弱三色不变式
+ 强三色不变式：不存在黑色对象到白色对象的引用关系
+ 弱三色不变式：所有被黑色对象引用的白色对象都处于灰色对象的保护状态

引入 **插入屏障** 和 **删除屏障**
+ 插入屏障：
  + 操作：A对象引用B对象的时候，B对象被标记为灰色。（将B挂在A下游，B必须被标记为灰色）
  + 满足：强三色不变式（不存在黑色引用白色，白色强制变为灰色）
+ 删除屏障：
  + 操作：被删除的对象，如果自身为灰色或白色，被标记为灰色
  + 满足：弱三色不变式（保护灰色对象到白色对象的路径不会断）

**混合写屏障**
  + 操作
    + GC 开始将栈上所有对象扫描并标记为黑色（之后不再进行二次扫描，无需STW）
    + GC 期间，任何在栈上创建的对象，都是黑色
    + 被删除的对象标记为灰色
    + 被添加的对象标记为灰色
  + 满足：变形的弱三色不变式

```plain-text
添加下游对象(当前下游对象slot，新下游对象ptr) {
    标记灰色(当前下游对象slot)
    if 当前 stack 是灰色:
        标记灰色(新下游对象ptr)
    当前下游对象slot=新下游对象ptr
}
```
+ 场景1：对象（白色）被某heap对象删除引用，成为stack对象的下游
  + 添加下游：stack不触发屏障，直接挂下游
  + 删除引用：heap对象，触发屏障，obj标记为灰色
+ 场景2：对象被某stack删除引用，成为另一个栈对象的下游
  + 添加下游：stack不触发屏障，直接挂下游 + 删除引用：stack不触发屏障，直接删除
+ 场景3：对象被某heap对象删除引用，成为另一个heap对象的下游
  + 添加下游：heap添加触发屏障，obj标记为灰色
  + 删除引用：heap删除触发屏障，obj标记为灰色
+ 场景4：从stack删除，成为heap下游
  + stack删除：不触发屏障，删除当前stack obj
  + heap删除&添加：heap操作触发屏障，删除heap当前obj引用下一个obj的引用，并将下一个obj标记为灰色 & heap当前obj添加对stack删除obj的引用（stack仍是黑色）
