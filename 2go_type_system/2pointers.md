# pointers

```golang
// 基类型(base type), 底层类型(underlying type)的概念?

// 1. 不同指针类型的转换(隐式 or 显式, 不借助 `unsafe.Pointer`)
// 2. 不同指针类型的比较

// 总体来说, 需要底层类型一致(underlying type), 
```

## 一个指针类型不能随意转换为另一个指针类型
只有满足如下两个条件, 一个类型`T1`才能被显式转换为另一个指针类型`T2`:
1. 类型`T1`和`T2`的底层类型必须一致(忽略结构体字段的标签), 特别地, 如果类型`T1`和`T2`中只要有一个是无名类型并且它们的底层类型一致(考虑结构体字段的标签), 则此转换可以是隐式的
2. 类型`T1`和`T2`都为无名类型并且它们的**基类型的底层类型一致(忽略结构体字段的标签)**
## 一个指针不能和另一指针类型进行比较
1. 这两个指针类型相同
2. 其中一个指针可以隐式转换为另一个指针类型。意味着，这两个指针类型的底层类型必须一致且其中一个指针类型为无名的（考虑结构体字段的标签）
3. 其中一个并且只有一个指针用类型不确定的`nil`表示

可以隐式转换的情况通常是:
```golang
// 1. Type definition.
type Ta *int64
// 2. Type alias.
// type Ta = *int64
var a Ta
var b *Ta
_ = a == b
```

## 上述Go指针的限制是可以被打破的
`unsafe`包中提供非安全类型指针`unsafe.Pointer`打破上述Go指针的安全限制。`unsafe.Pointer`类似C语言中的`void*`
